import numpy as np


def game_core_v1(number):
    '''Это - функция автора модуля, в неё изменения не вносилось.'''
    '''Просто угадываем на random, никак не используя информацию о больше или меньше.
       Функция принимает загаданное число и возвращает число попыток'''
    count = 0
    while True:
        count+=1
        predict = np.random.randint(1,101) # предполагаемое число
        if number == predict: 
            return(count) # выход из цикла, если угадали

        
def game_core_v2(number):
    '''Это - функция автора модуля, в неё изменения не вносилось.'''
    '''Сначала устанавливаем любое random число, а потом уменьшаем или увеличиваем его в зависимости от того, больше оно или меньше нужного.
       Функция принимает загаданное число и возвращает число попыток'''
    count = 1
    predict = np.random.randint(1,101)
    while number != predict:
        count+=1
        if number > predict: 
            predict += 1
        elif number < predict: 
            predict -= 1
    return(count) # выход из цикла, если угадали


def game_core_v3(number):
    '''МОЙ ВАРИАНТ: угадываем методом дихотомии (деления отрезка пополам):
    в качестве очередного предположения выступает число, равное половине разницы
    между предыдущим и последующим. Алгоритм угадывает не более чем за 7 шагов
    (для случая, если длина отрезка равна 100). Может быть модифицирован вместе
    с генератором случайных чисел для отрезка произвольной длины.'''
    count = 0 # счётчик попыток
    a = 1 # нижняя граница отрезка; первоначальное значение = 1
    b = 100 # верхняя граница отрезка; первоначальное значение = 100
    predict = 0 # инициализация переменной predict - текущего предположения
    predict_old = 0 # инициализация переменной predict_old - предыдущего предположения
    '''далее - цикл, осуществляющий дихотомию'''
    while number != predict:
        '''очередное предположение по формуле дихотомии'''
        predict = a + (b - a + 1) // 2
        '''необходимо делать проверку при приближении к концам исходного отрезка -
        - около 1 и 100: если очередное предположение совпадает с предыдущим,
        то искомое значение равно конецу отрезка (1 или 100)'''
        if (predict, predict_old) == (2, 2):
            predict = 1
            break
        elif (predict, predict_old) == (99,99):
            predict = 100
            break 
        # если нет - то находимся пока в процессе поиска внутри очередного отрезка [a; b]
        elif number > predict:
            a = predict
            b = max(b, predict_old)
        elif number < predict:
            b = predict
            a = min(a, predict_old)
        predict_old = predict
        count += 1
    return(count)

        
def score_game(game_core):
    '''Это - функция автора модуля, в неё изменения не вносилось.'''
    '''Запускаем игру 1000 раз, чтобы узнать, как быстро игра угадывает число'''
    count_ls = []
    np.random.seed(1)  # фиксируем RANDOM SEED, чтобы ваш эксперимент был воспроизводим!
    random_array = np.random.randint(1,101, size=(1000))
    for number in random_array:
        count_ls.append(game_core(number))
    score = int(np.mean(count_ls))
    print(f"Ваш алгоритм угадывает число в среднем за {score} попыток")
    return(score)


# запуск 1-го варианта: угадывание random-ным числом
# score_game(game_core_v1)


# запуск 2-го варианта: угадывание с использованием сравнения
# score_game(game_core_v2)


# запуск МОЕГО ВАРИАНТА (3-го): поиск методом дихотомии (деления отрезка пополам)
score_game(game_core_v3)
